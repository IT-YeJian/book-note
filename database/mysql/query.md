## 查询性能优化

如果查询写得很糟糕，即使库表结构再合理、索引再合适，也无法实现高性能

查询优化、索引优化、库表结构优化需要齐头并进，一个不落

## 1. 为什么查询速度会慢

查询的生命周期大致可以按照顺序来看，从客户端到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端

其中**执行** 可以认为是整个生命周期中最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序，分组等。

在完成这些任务的时候，查询需要在不同的地方花费时间，包括网络，cpu计算，生成统计信息和执行计划，锁等待（互斥等待）等操作，尤其是向底层存储引擎
检索数据的调用操作，这些调用需要在内存操作，cpu操作和内存不足时导致的I/O操作上消耗时间。根据存储引擎的不同，可能还会产生大量的上下文切换以及系统调用

在每一个消耗大量时间的查询案例中，我们都能看到一些不必要的额外操作，某些操作被额外地重复了很多次，某些操作执行的太慢等。优化查询的目的就是减少和消除这些
操作所花费的时间。

## 2. 慢查询基础：优化数据访问

查询性能低下最基本的原因时**访问的数据太多**。大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。对于低效查询，我们发现通过下面两个步骤来分析总是很有效：

- 确认应用程序是否在检索大量超过需要的数据。
- 确认mysql服务器是否在分析大量超过需要的数据行

## 2.1 是否向数据库请求了不需要的数据 

有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃。

典型案例

- 查询不需要的记录

    例如在新闻网站中取出100条记录，但是只在页面显示 前10条
- 多表关联时返回全部列
- 总是取出全部列

    取出全部列，会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的I/O、内存、和CPU消耗。一些DBA是严格禁止SELECT * 的写法。获取并缓存所有列的查询，相比多个独立的只获取部分列的查询可能就更有好处。
- 重复查询相同的数据

    例如在用户评论的地方需要查询用户头像的URL，那么用户多次评论的时候，可能就会反复擦好像这个数据。比较好的方案是，当初次查询的时候将这个数据缓存起来，需要的时候从缓存中取出，这样性能显然会更好。

## 2.2 mysql是否在扫描额外的记录

对于mysql，最简单的衡量查询开销的三个指标如下

- 响应时间
- 扫描的行数
- 返回的行数

这三个指标都会记录到MySQL的慢日志中，所以检查慢日志记录是找出扫描行数过多的查询的好方法

### 响应时间
响应时间是两个部分之和： 服务时间和排队时间

- 服务时间：数据库处理这个查询真正花了多长时间
- 排队时间： 服务器因为等待某些资源而没有真正执行查询的时间----可能是等待I/O操作完成，也可能是等待行锁，等等

### 扫描的行数和返回的行数

理想情况下，这两个数应该是相同的，但实际情况不是。例如在做一个关联查询时，服务器必须扫描多行才能生成结果集中的一行

### 扫描的行数和访问的类型

在EXPLAIN 语句中的type 列反映了访问类型。访问类型有很多种，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用。这里列的这些，速度都是从慢到快，扫描的行数也是从小到大。

如果查询没有办法找到合适的访问类型，那么解决的最好办法通常就是增加一个合适的索引。 索引让MySQL以最高效、扫描行数最少的方式找到需要的记录




