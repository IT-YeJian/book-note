### JVM如何加载字节码文件？
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

Java语言中类的加载、连接和初始化过程都是在程序运行期间完成的，领Java具备高度的灵活性。

类加载的过程：加载、连接（验证、准备、解析）、初始化。 

- 加载：通过一个类的名字获取此类的二进制字节流（PS：不限于从文件中读取）；将这个字节流代表的静态存储结构转换为方法区的运行时结构（由具体的虚拟机自己定义）；在内存中生成一个java.lang.Class对象，作为方法区这个类的各种数据结构的访问入口。
- 验证：文件格式验证、元数据验证（语义分析，类与类的继承关系等）、字节码验证（数据流和控制流分析）、符号引用验证（对类自身以外的信息进行匹配校验） 
- 准备：正式为类变量分配内存并设置初始值，这里类变量指的是被static修饰的变量。例外：如果类字段是常量，则在这里会被初始化为表达式指定的值。 
- 解析：将常量池内的符号引用替换为直接引用。符号引用：类似于OS中的逻辑地址；直接引用：类似于OS中的物理地址，直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。 
- 初始化：真正开始执行类中定义的Java程序代码；初始化用于执行Java类的构造方法。类初始化的过程是不可逆的，如果中间一步出错，则无法执行下一步，参见不可逆的类初始化过程。


###  什么情况下回出现Full GC，什么情况下会出现Young GC

- 对象优先在新生代Eden区中分配，如果Eden区没有足够的空间时，就会触发一次young gc
- Full gc的触发条件有多个，FULL GC的时候会STOP THE WORD。
    - 在执行Young gc之前，JVM会进行空间分配担保——如果老年代的连续空间小于新生代对象的总大小（或历次晋升的平均大小），则触发一次full gc。
    - 显式调用System.gc()方法时；
    - 大对象直接进入老年代，从年轻代晋升上来的老对象，尝试在老年代分配内存时，但是老年代内存空间不够；